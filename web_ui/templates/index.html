<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IDS Dashboard</title>
    <link rel="stylesheet" href="/static/style.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
<div class="sidebar">
    <h2>FlowGuard monitor</h2>
    <ul>
        <li class="active"><a href="/">Dashboard</a></li>
        <li><a href="/logs">Logs</a></li>
    </ul>
</div>

<div class="main">
    <header>
        <h1> FlowGuard IDS</h1>
        <div class="header-controls">
            <button id="refreshBtn" onclick="loadRecentAlerts()">Refresh</button>
            <span id="lastUpdated"></span>
        </div>
    </header>
    <div class="interface-selector">
        <label for="interface">Select Interface:</label>
        <select id="interface"></select>
        <button id="applyIface">Apply</button>
    </div>
    <section class="graph">
        <h2>Live Traffic</h2>
        <div class="graph-container">
            <canvas id="trafficChart"></canvas>
        </div>
    </section>

    <section class="stats">
        <h2>Statistics</h2>
        <div class="stats-container">
            <div class="stat-card">
                <h3>Total Alerts</h3>
                <p id="totalAlerts">0</p>
            </div>
            <div class="stat-card">
                <h3>Recent Activity</h3>
                <p id="recentAlerts">0</p>
            </div>
            <div class="stat-card">
                <h3>Last Update</h3>
                <p id="lastUpdate">-</p>
            </div>
        </div>
    </section>

    <section class="alerts">
        <h2>Recent Alerts</h2>
        <div id="loadingSpinner" class="loading">Loading recent alerts...</div>
        <div id="errorMessage" class="error" style="display: none;"></div>
        <table>
            <thead>
            <tr>
                <th>Time</th>
                <th>Source IP</th>
                <th>Destination IP</th>
                <th>Threat</th>
                <th>Confidence</th>
            </tr>
            </thead>
            <tbody id="alertsTableBody">
            <!-- JS will inject rows -->
            </tbody>
        </table>
    </section>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
<script>
    // Initialize Socket.IO
    const socket = io();
    
    // Listen for new alerts
    socket.on('new_alert', function(alert) {
        function updateRecentAlerts() {
            const alertsTableBody = document.getElementById('alertsTableBody');
        const lastUpdated = document.getElementById('lastUpdated');

        // Create a new row for the incoming alert
        const row = document.createElement('tr');
        row.innerHTML = `
            <td class="timestamp">${alert.timestamp}</td>
            <td class="ip-address">${alert.source_ip}:${alert.source_port}</td>
            <td class="ip-address">${alert.destination_ip}:${alert.destination_port}</td>
            <td class="threat-type">${alert.threat_type}</td>
            <td class="confidence">${alert.confidence}</td>
        `;

        // Prepend the new alert row at the top of the table
        if (alertsTableBody.firstChild && alertsTableBody.firstChild.textContent === 'No recent alerts') {
            // Remove "No recent alerts" placeholder if present
            alertsTableBody.innerHTML = '';
        }
        alertsTableBody.insertBefore(row, alertsTableBody.firstChild);

        const maxAlerts = 5;
        while (alertsTableBody.children.length > maxAlerts) {
            alertsTableBody.removeChild(alertsTableBody.lastChild);
        }

        // Update last updated timestamp
        lastUpdated.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
        }

        // Update recent alerts table
        updateRecentAlerts();
        
        // Update traffic chart
        updateTrafficData();
        
        // Update statistics
        updateStats();
    });

    // Function to update statistics
    async function updateStats() {
        try {
            const response = await fetch('/api/stats');
            if (!response.ok) throw new Error('Failed to fetch stats');
            
            const result = await response.json();
            if (!result.success) throw new Error(result.error);

            const stats = result.data;
            document.getElementById('totalAlerts').textContent = stats.total_alerts;
            document.getElementById('recentAlerts').textContent = stats.recent_alerts_count;
            document.getElementById('lastUpdate').textContent = stats.last_update;
        } catch (error) {
            console.error('Error updating stats:', error);
        }
    }

    // Function to load recent alerts
    async function loadRecentAlerts() {
        const loadingSpinner = document.getElementById('loadingSpinner');
        const errorMessage = document.getElementById('errorMessage');
        const alertsTableBody = document.getElementById('alertsTableBody');
        const lastUpdated = document.getElementById('lastUpdated');

        // Show loading spinner
        loadingSpinner.style.display = 'block';
        errorMessage.style.display = 'none';

        try {
            const response = await fetch('/api/recent-alerts');

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();

            if (result.success) {
                // Clear existing rows
                alertsTableBody.innerHTML = '';

                if (result.data.length === 0) {
                    alertsTableBody.innerHTML = '<tr><td colspan="5">No recent alerts</td></tr>';
                } else {
                    // Add each alert as a table row
                    result.data.forEach(alert => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="timestamp">${alert.timestamp}</td>
                            <td class="ip-address">${alert.source_ip}:${alert.source_port}</td>
                            <td class="ip-address">${alert.destination_ip}:${alert.destination_port}</td>
                            <td class="threat-type">${alert.threat_type}</td>
                            <td class="confidence">${alert.confidence}</td>
                        `;
                        alertsTableBody.appendChild(row);
                    });
                }

                lastUpdated.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
            } else {
                throw new Error(result.error || 'Failed to fetch alerts');
            }

        } catch (error) {
            console.error('Error loading alerts:', error);
            errorMessage.textContent = `Error loading alerts: ${error.message}`;
            errorMessage.style.display = 'block';
        } finally {
            loadingSpinner.style.display = 'none';
        }
    }

    // Initialize traffic chart
    let trafficChart;
    const maxDataPoints = 20;
    const trafficData = {
        labels: [],
        datasets: [{
            label: 'Packets/sec',
            data: [],
            borderColor: '#007bff',
            backgroundColor: 'rgba(0, 123, 255, 0.1)',
            tension: 0.4,
            fill: true
        }]
    };

    function initTrafficChart() {
        const ctx = document.getElementById('trafficChart').getContext('2d');
        trafficChart = new Chart(ctx, {
            type: 'line',
            data: trafficData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Packets'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                }
            }
        });
    }

    // Function to update traffic data
    async function updateTrafficData() {
    try {
        const response = await fetch('/api/traffic');
        if (!response.ok) throw new Error('Failed to fetch traffic data');

        const result = await response.json();
        if (!result.success) throw new Error(result.error);

        const points = result.data;
        if (!points.length) return;

        // Clear old data
        trafficData.labels = [];
        trafficData.datasets[0].data = [];

        points.slice(-maxDataPoints).forEach(point => {
            const timeLabel = new Date(point.timestamp).toLocaleTimeString();
            trafficData.labels.push(timeLabel);
            trafficData.datasets[0].data.push(point.packet_count);
        });

        trafficChart.update();
    } catch (error) {
        console.error('Error updating traffic data:', error);
    }
}


    // Load alerts and initialize chart when page loads
    document.addEventListener('DOMContentLoaded', function() {
        loadRecentAlerts();
        initTrafficChart();
        updateStats();
        
        // Auto-refresh alerts every 30 seconds
        setInterval(loadRecentAlerts, 30000);
        
        // Update traffic data every 5 seconds
        setInterval(updateTrafficData, 5000);
        updateTrafficData(); // Initial update
        
        // Update stats every minute
        setInterval(updateStats, 60000);
    });

    fetch("/api/interfaces")
    .then(response => response.json())
    .then(data => {
      const ifaceSelect = document.getElementById("interface");
      data.interfaces.forEach(iface => {
        const option = document.createElement("option");
        option.value = iface;
        option.text = iface;
        ifaceSelect.appendChild(option);
      });
    });

  // Handle interface selection
  document.getElementById("applyIface").onclick = () => {
    const selected = document.getElementById("interface").value;
    socket.emit("select_interface", { interface: selected });
  };

  // Listen for confirmation
  socket.on("interface_selected", (data) => {
    if (data.success) {
      alert("Interface changed to: " + data.interface);
    } else {
      alert("Error: " + data.error);
    }
  });
</script>
</body>
</html>